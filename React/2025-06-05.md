## 2025-06-05

- useEffectでAPIを取得するとシンプルに書ける

### before useEffect
```
  const [breeds, setBreeds] = useState();
  async function getData() {
    const url = "https://dog.ceo/api/breeds/list/all";
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`レスポンスステータス: ${response.status}`);
      }
  
      const json = await response.json();
      return json; 
    } catch (error) {
      console.error(error.message);
      return null;
    }
  }
  async function dogBreeds(){
    const dogBreeds = await getData();
    if(dogBreeds){
      setBreeds(dogBreeds);
    }
  }
```

### after useEffect
```
  const [breeds, setBreeds] = useState();
  useEffect(() => {
    fetch('https://dog.ceo/api/breeds/list/all')
    .then(res => res.json())
    .then(data => setBreeds(data));
  }, []);
```

---

### ✏️useEffect間違えポイント

- useEffectの第二引数は最初の()の中ではなく、後ろの[]を指す

---

# useEffect が走るタイミングについて

## 🔄 useEffect の実行タイミング

### 1. 初回マウント後（初回レンダリング完了後）

```javascript
useEffect(() => {
  console.log("マウント時に1回だけ実行される");
}, []);
```

- DOM が描画された**あと**に実行される
- 空の依存配列 `[]` を渡すことで、一度だけ実行される
- ✅ 主に初期データの取得（API 呼び出し）などに使う

### 2. 依存配列の値が変化したとき

```javascript
useEffect(() => {
  console.log("count が変化したとき実行される");
}, [count]);
```

- `count` の値が変わるたびに再実行される
- ✅ 特定の状態や props に合わせて処理したいときに使う

### 3. 依存配列なし（毎回実行）

```javascript
useEffect(() => {
  console.log("毎回レンダリング後に実行される");
});
```

- すべてのレンダリングのたびに実行される
- ⚠️ パフォーマンスに悪影響を及ぼすため通常は非推奨

## 🌐 なぜ API 呼び出しに使うのか？

- React コンポーネントは状態更新で何度もレンダリングされる
- API 呼び出しを render 内や関数外に直接書くと、無限ループや過剰アクセスの原因になる

### ✅ 解決方法：useEffect で初回マウント時に一度だけ呼び出す

```javascript
useEffect(() => {
  fetch('/api/something')
    .then(res => res.json())
    .then(data => setData(data));
}, []);
```

- 初回だけ API を呼び、安定して必要なデータを取得できる
- 非同期処理 (fetch, axios など) を副作用として安全に扱える


